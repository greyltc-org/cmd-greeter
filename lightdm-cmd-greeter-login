#!/usr/bin/env python3
# this file is the login front end
# it relays messages between the user and the greeter server

import sys
import getpass
from gi.repository import GLib
from gi.repository import Gio


class LoggerInner(object):
    greeter_server_dbus_address = "com.greyltc.cgreet"

    def __init__(self, *args, **kwargs):
        self.greeter_server_dbus_path = '/' + self.greeter_server_dbus_address.replace('.','/')

        # connect to the system dbus
        system_bus = Gio.bus_get_sync(Gio.BusType.SYSTEM, None)

        # server proxy
        srv_prx_setup = {}
        srv_prx_setup['connection'] = system_bus
        srv_prx_setup['flags'] = Gio.DBusProxyFlags.DO_NOT_AUTO_START
        srv_prx_setup['info'] = None
        srv_prx_setup['name'] = self.greeter_server_dbus_address
        srv_prx_setup['object_path'] = self.greeter_server_dbus_path
        srv_prx_setup['interface_name'] = self.greeter_server_dbus_address
        srv_prx_setup['cancellable'] = None
        self.srv_prx = Gio.DBusProxy.new_sync(**srv_prx_setup)

        # create the main loop object
        self.loop = GLib.MainLoop.new(None, False)

        # setup signal handler
        self.srv_prx.connect('g-signal', self.handle_signal, None)
        #self.system_bus.subscribe(object = self.greeter_server_dbus_path, signal_fired = self.prompt_action)

        # connect to the server
        #self.server = self.system_bus.get(self.greeter_server_dbus_address)

    # calls a function over dbus
    def db_call(self, proxy, method_name, parameters=None, flags=Gio.DBusCallFlags.NO_AUTO_START, timeout_msec=500, cancellable=None):
        call_setup = {}
        call_setup['method_name'] = method_name
        call_setup['parameters'] = self.to_variant(parameters)
        call_setup['flags'] = flags
        call_setup['timeout_msec'] = timeout_msec
        call_setup['cancellable'] = cancellable
        return proxy.call_sync(**call_setup)

    # takes a list of python objects and tries to make them into a GLib Variant
    def to_variant(self, things):
        if things is None:
            return None
        else:
            types=''
            for thing in things:
                if isinstance(thing, str):
                    types = types+'s'
                elif isinstance(thing, int):
                    types = types+'i'
                elif isinstance(thing, float):
                    types = types+'d'
                elif isinstance(thing, bool):
                    types = types+'b'
                else:
                    print(f"DANGER: I can't gVariant {thing} of type {type(thing)}")
            return GLib.Variant(f"({types})", things)

    def handle_signal(self, proxy, sender_name, signal_name, parameters, user_data):
        if signal_name == 'prompt_text':
            prompt = parameters[0]
            if "assword" in prompt:
                response = getpass.getpass(prompt)
            else:
                response = input(prompt)
            self.db_call(proxy, 'respond', parameters=[response])
        elif signal_name == "auth_complete":
            success = parameters[0]
            if success == True:
                print("Authentication successful!")
            else:
                print("Authentication failed!")
            
            # quit the main loop
            self.loop.quit()
    
    def run(self):
        # start the authentication routine
        self.db_call(self.srv_prx, 'authenticate')

        # run the main loop
        self.loop.run()


if __name__=="__main__":
    li = LoggerInner(sys.argv)
    li.run()
